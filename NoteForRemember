1, 非匿名函数存在name属性(函数的名称),匿名函数不存在name属性

2, 函数表达式,变量被提升,但当使用函数声明时,函数定义也被提升,而不仅仅是函数声明被提升

3, 函数被在自身内部重定义以后,已经添加到原始函数的任何属性都会丢失.

4, 创建函数时,它都会自动获得一个length属性,其中包含了该函数期望的参数数量

5, 对于构造函数的一般经验法则是:应该将可复用的成员添加到原型中

6, javascript继承模式:
    1 默认模式
    function  inherit(C, P) {
      C.prototype = new P();
    }
    缺点:不支持将参数传递到子构造函数中
    
    2 借用构造函数
    function Child(a, c, b, d) {
      Parent.apply(this, arguments);
    }
    重点:子类在借用构造函数的时候,新对象会获得父对象中中的成员副本(不是引用)
    缺点:没有原型,所以就没有原型继承,父对象原型中的属性和方法不能用
    
    3 借用和设置原型
    很好理解啦
    
    4 共享原型 
    function inherit(C, P) {
        C.prototype = P.prototype;
    }
    法则:可复用成员应该转移到原型中而不是放置在this中
    
