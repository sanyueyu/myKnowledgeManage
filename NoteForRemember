1, 非匿名函数存在name属性(函数的名称),匿名函数不存在name属性

2, 函数表达式,变量被提升,但当使用函数声明时,函数定义也被提升,而不仅仅是函数声明被提升

3, 函数被在自身内部重定义以后,已经添加到原始函数的任何属性都会丢失.

4, 创建函数时,它都会自动获得一个length属性,其中包含了该函数期望的参数数量

5, 对于构造函数的一般经验法则是:应该将可复用的成员添加到原型中

6, javascript继承模式:
    1 默认模式
    function  inherit(C, P) {
      C.prototype = new P();
    }
    缺点:不支持将参数传递到子构造函数中
    
    2 借用构造函数
    function Child(a, c, b, d) {
      Parent.apply(this, arguments);
    }
    重点:子类在借用构造函数的时候,新对象会获得父对象中中的成员副本(不是引用)
    缺点:没有原型,所以就没有原型继承,父对象原型中的属性和方法不能用
    
    3 借用和设置原型
    很好理解啦
    
    4 共享原型 
    function inherit(C, P) {
        C.prototype = P.prototype;
    }
    法则:可复用成员应该转移到原型中而不是放置在this中
    
    5 临时构造函数
    function inherit(C, P) {
        var F = function() {};
        F.prototype = P.prototype;
        C.prototype = new F();
    }
    好处不少 称为"圣杯"
    
    ``大部分基于类的语言中,每次在调用子类的构造函数时,父类的构造函数也将被自动调用
    ``避免使用以上
    
    6 原型继承
    function object(o) {
        function F() {}
        F.prototype = o;
        return new F();
    }

7 只是用一个var在函数顶部进行变量声明时一种非常有用的模式(尤其用于DOM文档的引用,是用单一var声明将DOM引用赋值给局部变量)

8 过滤掉原型链上的属性时,使用hasOwnProperty()方法

9 parseInt(year, 10);最好加上十进制
