1, 同源策略: 主要是脚本所嵌入的文档的来源

2, 解决定时器容易错乱的方法是,看是否有多余的定时器,1个便ok

3, 循环动态绑定事件可以通过闭包解决

4, 嵌套函数中的this不会指向调用外层函数的上下文-----解决:用self变量保存this

5, javascript 自上而下加载解析到document,遇到词法错误,语法错误,会跳出本段<script>标签,但是还会继续加载随后的<script>标签中的javascript代码,如此循环,知道document加载完毕

6, prototype 原型其实就是一个对象

7, 实现bind函数 function bind(f, o) {   如此简单,-----------关注  proxy函数,且jquery已经实现:$.proxy();
                  if(f.bind) return f.bind(o);
                  else return function () {
                    return f.apply(o, arguments);
                  };
                }

8, new F()如果没有返回值(Undefined类型)，或返回值是5种基本型（Undefined类型、Null类型、Boolean类型、Number类型、String类型）之一，则new F()我们可以看成是原型扩展方法中的this; 如果返回是是数组啊、对象啊什么的，则返回值就是这些对象本身，此时new F() ≠ this。
    加深理解:如下var F = function() {
    return "sssss";(若将此处返回{}则会报错,hide无法使用)
};
F.prototype.hide = function() {
    console.log("hello im hide");
};
new F().hide();              

9, context 其实没有这个关键字,都用它来做参数,代表上下文环境,如document等

10, '&&'短路(short circuiting) 运算符首先计算左操作数的值,如果计算结果是假值,'&&'这时简单地返回左操作数的值,而不会对右操作数进行计算.要注意&&运算符排在赋值运算符'='前

11, 用于深入理解构造函数
function inherit(o) {
    var f = function(){};
    f.prototype = o;
    return new f();
}

function range(from, to) {
    var r = inherit(range.methods);
    
    r.from = from;
    r.to = to;
    return r;
}
range.methods = {
    sum: function() {return this.from + this.to;}
};

var hello = range(13, 12);
console.log(hello.sum());

12, 函数调用在圆括号内包含一组实参列表,先计算这些实参表达式,然后传入函数内

13, 同上,return语句,先计算return语句后的expression,然后再返回expression的值给调用程序

14, 关联闭包的作用域链都是"活动的",记住这一点非常重要,嵌套的函数不会将作用域内的私有成员复制一份,也不会对所绑定的变量生成静态快照(static snapshot)\
function cont() {
    var a = [];
    for(var i = 0; i< 10; i++) a[i] = function() {return i};
    return a;
}

var test = cont();
test[3](); //返回10

15, 再学bind:ES3.0实现bind
                  if(typeof Function.prototype.bind == 'undefinde') {
                      Function.prototype.bind = function(thisArg) {
                          var fn = this,
                              slice = Array.prototype.slice,
                              args = slice.call(arguments, 1);
                          return function() {
                              return fn.applay(thisArg, args.concat(slice.call(arguments)));
                          };
                      }                                    
                  }
     其中两点需要说明: 1 两处的arguments不是同一arguments
                       2 thisArg指的是第一个参数

16, 深入理解JS函数作用域 和 事件动态绑定
    病状:for (var i = 0, len = $("li").length; i < len; i++) {
            $($("li")[i]).bind("click", function () {
                console.log(i);
            });
    }//每次点击li标签,显示的都是3有木有
    病因:JS函数作用域,不是块状作用域,亲,此处for循环没有作用域,每次读取的都是同一个i的值
         在循环语句里面创建的变量也是拥有函数调用作用域或是全局作用域的，并不会有临时变量存在
         详细描述见<权威指南>P59 作用域链的讲解
    对症下药:for (var i = 0, len = $("li").length; i < len; i++) {
               (function (i) {//创建函数保留i
                 $($("li")[i]).bind("click", function () {
                     console.log(i);
                 });
             })(i)
           }
    或者分开写:
    function a(){
    for(var i = 0, len = $("li").length;i < len; i++) {
        console.log($("li")[i]);
        b(i);
    }

    }
    function b(i){
    $($("li")[i]).bind("click", function() {
        console.log(i);
    });
     }
  a();

17 比较运算符更偏爱数字,只有在两个操作数都是字符串的时候,才会进行字符串的比较

18 对象是带有行为的数据,函数式带有数据的行为

19 "栈"如同米缸 先放进去的米最后才能拿出来
