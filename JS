1, 同源策略: 主要是脚本所嵌入的文档的来源

2, 解决定时器容易错乱的方法是,看是否有多余的定时器,1个便ok

3, 循环动态绑定事件可以通过闭包解决

4, 嵌套函数中的this不会指向调用外层函数的上下文-----解决:用self变量保存this

5, javascript 自上而下加载解析到document,遇到词法错误,语法错误,会跳出本段<script>标签,但是还会继续加载随后的<script>标签中的javascript代码,如此循环,知道document加载完毕

6, prototype 原型其实就是一个对象

7, 实现bind函数 function bind(f, o) {   如此简单,-----------关注  proxy函数,且jquery已经实现:$.proxy();
                  if(f.bind) return f.bind(o);
                  else return function () {
                    return f.apply(o, arguments);
                  };
                }

8, new F()如果没有返回值(Undefined类型)，或返回值是5种基本型（Undefined类型、Null类型、Boolean类型、Number类型、String类型）之一，则new F()我们可以看成是原型扩展方法中的this; 如果返回是是数组啊、对象啊什么的，则返回值就是这些对象本身，此时new F() ≠ this。
    加深理解:如下var F = function() {
    return "sssss";(若将此处返回{}则会报错,hide无法使用)
};
F.prototype.hide = function() {
    console.log("hello im hide");
};
new F().hide();              

9, context 其实没有这个关键字,都用它来做参数,代表上下文环境,如document等

10, '&&'短路(short circuiting) 运算符首先计算左操作数的值,如果计算结果是假值,'&&'这时简单地返回左操作数的值,而不会对右操作数进行计算.
